[{"categories":null,"content":"Volta e meia eu fico muito aficionado por algum tema da computação. Às vezes é um assunto já batido, que encontro de monte por aí, mas geralmente é algo mais específico, que alguns conhecem e poucos usam. O tema da vez foi o Incus, um sistema de virtualização e containers derivado do LXD, voltado para quem precisa de algo mais leve que uma VM, mas mais completo que um container tradicional. E foi quando me convidaram para falar em uma apresentação que fiquei empolgado por dois motivos: primeiro, porque seria a minha primeira apresentação e já tinha um tempo que eu queria ver como me sairia em uma e, segundo, porque eu poderia falar sobre Incus e LXD. Comecei a pensar em como abordar e percebi que poderia acabar trazendo apenas vários hands-on e conceitos de virtualização. Fiquei tentado a fazer uma linha quase histórica sobre virtualização e seus usos, mas me imaginei falando 40 minutos só disso… e talvez eu não fosse a melhor pessoa para esse tipo de narrativa (nem ficaria realmente feliz fazendo). Então decidi retomar alguns tópicos que vinha pensando e conceitos que vi quando estive no MGC: daemon, o próprio Incus, Golang e… Operadores. Nesse momento, resolvi juntar tudo e focar em algo mais prático como um lab: explicar algo próximo do dia a dia do dev (talvez não de todos), mas ao mesmo tempo experimentar umas coisas. E assim surgiu o tema: Operator Pattern além do K8s: IaC Reativa com Primitivos do Linux. Mas para chegar no lab precisamos entender algumas coisas. ","date":"2025-09-02","objectID":"/posts/operatorpattern/:0:0","series":null,"tags":null,"title":"Operator Pattern além do K8s","uri":"/posts/operatorpattern/#"},{"categories":null,"content":" Mas afinal, o que são operadores?Para explicar isso, precisamos falar de quem está sempre atrelado a eles: o Kubernetes. De forma simples, o K8s é um orquestrador de containers. Mas o que significa orquestrar? Nesse caso, é automatizar deploy, escalabilidade e gerenciamento de aplicações e resiliencia. Simplista? Talvez. Então vamos um pouco mais fundo. O K8s foi pensado para ambientes grandes, com muitos componentes, o famoso mundo de microserviços. Ele lida muito bem com sistemas distribuídos, e por isso exige uma arquitetura distribuída (embora haja controvérsias). No coração dessa arquitetura, temos duas entidades principais: Control Plane: basicamente nele ficam as orquestrações. Ele orquestra as requisições pelo API Server, guarda estados no ETCD (banco NoSQL do K8s), agenda cada pod com o Schedular e mantém monitoramento constante do estado do sistema, garantindo resiliência com os Controllers. Worker Nodes: onde vivem os pods e onde a ação ocorre. Aqui temos o agente que executa as ações, quem gerencia a rede e o runtime dos containers. Um desses exemplos é o Kubelet. Resumindo: quando você cria seu YAML, roda o kubemine start e depois apply nos manifestos se define um estado desejado para o cluster. O API Server recebe essa intenção, salva no ETCD e passa a ordem para o Scheduler decidir onde colocar cada recurso. Assim que o Schedular gera esse agendamento o Api Server ordena o Kubelet a trabalhar nos pods sendo criando, deletando e etc. Mas focando nos Controllers que ficaram de fora desse fluxo, eles garantem que tudo fique no estado correto. Se um pod falha, o Controller que está monitorando avisa o Api Server para ele dar a ordem de criação (desde que isso esteja definido, claro). Esse design todo tem um core quando falamos em resiliência (o trunfo do K8s): o Reconciliation Loop (esse nome o K8s deu) ou Control Loop (esse eu não sei quem deu, mas é mais velho). É nele que a mágica acontece. Observar o estado atual, comparar com o desejado e agir se necessário. Isso é exatamente o que os operadores fazem e isso fica dentro dos Controllers. ","date":"2025-09-02","objectID":"/posts/operatorpattern/:1:0","series":null,"tags":null,"title":"Operator Pattern além do K8s","uri":"/posts/operatorpattern/#mas-afinal-o-que-são-operadores"},{"categories":null,"content":" Operadores: o SRE codificadoOperadores automatizam conhecimento específico de domínio. É como se um SRE experiente estivesse codificado em software, pronto para agir dentro do cluster. Exemplo prático: o K8s escala pods baseado em CPU e memória. Mas e se quisermos algo mais inteligente, como escalar com base no tamanho de uma fila de mensagens? O operador interage com o API Server por meio de um CRD (Custom Resource Definition), que define um novo tipo de recurso. A partir da especificação YAML (define o estado desejado pelo usuário), o operador atua como um controller especializado: observa a fila, contabiliza mensagens e, quando necessário, aumenta ou reduz o número de pods. Percebe o padrão? O operador replica o que um SRE faria manualmente: observar métricas específicas do domínio, tomar decisões inteligentes e age automaticamente. Aqui a gente consegue ver isso acontencendo, o controller no meio agindo como operador ele busca métricas de uma fila no Metrics faz a lógica de comparação no scaller já tomando a decisão de agir e com isso passa a vez para o Controller que é quem se comunica com o Api Server. Lindo de se ver ","date":"2025-09-02","objectID":"/posts/operatorpattern/:2:0","series":null,"tags":null,"title":"Operator Pattern além do K8s","uri":"/posts/operatorpattern/#operadores-o-sre-codificado"},{"categories":null,"content":" Mas… eu já vi isso antesQuando vi o K8s chamar isso de “Operator Pattern”, fiquei pensando em como eles foram geniais, fiquei impressionado, eles conseguiram dar nome e estrutura a algo que fazíamos há décadas de forma ad-hoc. Tipo eu pensei: eu já vi esse padrão antes. E vocês também. Só que não necessariamente dentro do K8s. Primeiro, entendendo no macro ou micro, não sei muito bem, tem essa imagem que eu criei apartir de uma ideia: A ideia é simples demonstrar que o paralelo entre o K8s e maquinas de estado e tudo que tem entre eles. Foi uma adaptação de um tipo bem primitivo até chegar no K8s que conhecemos hoje. sim, peguei um slide da apresentação, pois só vi esse paralelo depois de escrever o roteiro e agora estou retocando para o texto Na prática, estamos falando de reconciliação — o famoso “observe, compare e aplique”. Esse conceito existe há muito tempo: 1975–1990: Unix e Linux faziam isso com cron + shell scripts, trazendo um tom de reconciliação rudimentar: text observe = hora compare = agenda act = run script 2005–2010: ferramentas de config management, como Puppet fazem o mesmo com scripts manuais e seus manifestos: text observe = estado real da máquina compare = manifesto act = install 2010: surge o systemd (para alegria de muitos e tristeza de outros), com um control loop baseado em falha: text observe = daemon status compare = unit file act = restart service 2011–2014: o boom do IaC com Terraform, com control loop similar ao config management. 2014 – atual: K8s e operadores consolidam esse padrão. É o que vemos agora. Provavelmente teve muitos outros que deixei de fora, vale a pesquisa! ","date":"2025-09-02","objectID":"/posts/operatorpattern/:3:0","series":null,"tags":null,"title":"Operator Pattern além do K8s","uri":"/posts/operatorpattern/#mas-eu-já-vi-isso-antes"},{"categories":null,"content":" Amarrando tudoAgora vamos trazer um pouco de contexto e base do padrão control loop em um Lab. Quero dizer, meu divertimento começa agora (na verdade já foi agora estou escrevendo o que também é divertido exceto que sou meio meh nisso). A ideia: criar um lab para demonstrar um operador usando primitivos do Linux, um pouco de Go, Incus e entregar um HPA para containers Incus. É isso mesmo. Bora ver um pouco. Aliás, o código todo que usei nesse lab está disponível aqui: https://github.com/LucasRiboli/Forge-Operator-Lab Primeiro passo acredito que seria clonar o repo: bash git clone https://github.com/LucasRiboli/Forge-Operator-Lab.git cd Forge-Operator-Lab O próximo passo, seria entender primeiro o que eu fiz. Para isso, tem um desenho: Aqui eu tentei trazer uma visão proxima a do K8s já que ele é nossa base, porém muita coisa foi abstraida. Vale entender também pela img da direita como é o fluxo, ja a imagem da esquerda ela é uma representação com as demais que fui trazendo, acredito que ajude também OBS: Esse lab não é sobre substituir o Kubernetes (kkkk obvio né), mas sim mostrar como o operator pattern pode ser aplicado em qualquer infraestrutura, (com primitivos simples do Linux nesse caso). A ideia é abrir espaço para experimentos, forks e adaptações. Ok, explicado isso vamos nos voltar para o código e ver o core do nosso control loop a func runHPALoop: Por que ela é o core? Bom, porque nela está o processo do control loop inteiro:: observe: go for _, container := range hpaPods { if container.State.Status == \"Running\" { state, err := getInstanceState(container.Name) if err != nil { log.Printf(\"Erro ao capturar estado do pod %s: %v\", container.Name, err) continue } if state.Memory.Total \u003e 0 { porcentagemPod := (state.Memory.Usage * 100) / state.Memory.Total sumMemory += porcentagemPod runningPods++ log.Printf(\"Pod %s: %d%% memória utilizada\", container.Name, porcentagemPod) } } } compare: go if totalMediaMemory \u003e= int64(hpa.HPA.MemoryThreshold) { if runningPods \u003c int64(hpa.HPA.MaxPods) {...} } \u0026 go if totalMediaMemory \u003c int64(hpa.HPA.MemoryThreshold)/2 { if runningPods \u003e int64(hpa.HPA.MinPods) {...} } act: go return createPod(name) go return deletePod(podToDelete) Resumindo: text observe -\u003e medir uso de memória dos pods compare -\u003e checar se está acima/abaixo do threshold act -\u003e criar ou apagar pods Todos o resto do código basicamente é apoio/lógica ou o Incus executando alguma acao. Recomendo olharem e entenderem também. Entendendo esse padrão em código, podemos avancar em como iniciar essa aplicação toda. Primeiro, instalar o Incus seguindo o passo a passo da documentação oficial (https://linuxcontainers.org/incus/docs/main/installing/) Após fazer isso pode seguir gerando um executavel do nosso sistema: go go build -o operador cmd/main.go e em seguida instale nosso daemon bash sudo ./operador/install-daemon.sh após isso crie um container com o nome pod dentro do incus e estresse ele para ver a magina acontecer para isso pode rodar bash sudo ./lab-init.sh Basicamente, assim você teria seu HPA baseado em memória para o cluster Incus, com o daemon operador como base de controle e o código (que você pode ajustar) operando tudo. Enfim, experimente alterar o estado desejado para desligar o container em vez de subir outro. O operador deve reagir e aplicar essa mudança. Essa é a mágica: você descreve o que quer, e o loop garante que se torne realidade Por fim era isso, gostei mto de fazer esse estudo e esse lab para a apresentacao e transformar ele em texto e segue sendo bom criar labs e compartilhar. ","date":"2025-09-02","objectID":"/posts/operatorpattern/:4:0","series":null,"tags":null,"title":"Operator Pattern além do K8s","uri":"/posts/operatorpattern/#amarrando-tudo"},{"categories":null,"content":" Daemons: Da Física (?) ao Controle de Sistemas LinuxSe tem conceitos e histórias que eu sempre gostei são as relacionadas a fisica, mitologia e computação. E passando por ai na interwebs e dia a dia de trabalho me deparei certa vez com os DAEMONS, bom O nome ja chama a atenção e na minha opinião as relações e conceitos também então, bora ver mais. Em 1871 (embora ja houvesse citado ela 1867), James Clerk Maxwell, para explicar a segunda lei da termodinâmica, propôs um experimento mental que refutasse ela. Ele imaginou um ser finito, capaz de manipular moléculas em um sistema fechado, que observava e tomava decisões sobre abrir ou fechar uma porta para permitir a passagem de moléculas rápidas, basicamente de acordo com ele um ser impossivel de existir. Mais tarde, Lord Kelvin chamou esse ser de “demônio”, não no sentido ruim da coisa (ele nao quis dizer, mochila de criança, 7 pele, sintéco gelado…), mas referindo-se a uma criatura sobrenatural que trabalha nos bastidores, o conceito de daemon da mitologia grega, seres invisíveis aos humanos, executando tarefas importantes. Este conceito de “daemon” é frequentemente associado na computação, embora a ligação talvez nem exista, no contexto dos computadores, o termo assumiu seu próprio significado técnico específico (mas vamos supor que existe a ligação, deixa tudo mais legal). Mas porque teria essa ligação? Bom a ideia geral é a mesma, mas não mais como um experimento mental, mas como algo virtual. Nos sistemas operacionais, temos que manter o sistema complexo sob constante observação e ação, sem a intervenção direta do usuário, ou seja, um verdadeiro daemon grego. E voiala temos ai, os Daemons do linux. Eles permanecem em estado de dormência (ele nao fica de fato off, mas vou explicar melhor mais pra frente), sendo executados por algum gatilho, em intervalos regulares (geralmente segundos ou milissegundos), ou ainda processando filas continuamente. Existem de todos os tipos e funções, mas a constante é: eles operam de forma autônoma, sem depender da ação do usuário, mantendo o funcionamento do sistema operacional ou gerenciando funções que, eventualmente, podem ser usadas por processos interativos. Um exemplo importante de sistema de gerenciamento de daemons e amplamente adotado em muitas distribuições modernas, é o systemd. Ele funciona como um gerenciador central: inicia e controla muitos outros serviços, analisando arquivos .service para determinar a ordem de execução, localização do binário do processo, e como gerenciar suas entradas e saídas. Na prática, daemons são a base do Linux, atuando em diversos níveis, desde funções próximas ao hardware até aplicações de usuário. Quase tudo o que usamos ou vemos em nosso workflow tem um daemon por trás. E o melhor, podemos criar nossos próprios daemons para executar tarefas que não requerem nossa atenção direta, funcionando em segundo plano. Hoje, em muitos sistemas modernos, o systemd é um gerenciador de daemons amplamente utilizado, embora existam alternativas como OpenRC, runit e s6 que têm seus próprios méritos e defensores. Com o systemd, podemos, por exemplo, criar um serviço que monitora a temperatura do hardware e gera logs automaticamente, ou executar aplicações “one shot” sob seu controle, gerenciando sua execução, status e eventuais erros. Claro, existem diversos outros daemons, como eu disse, eles estão por tudo e até onde a gente talvez (?) nem imagine, como o Apache HTTP Server (httpd), que é um servidor web popular que opera como daemon (eu não sabia até ir atrás). Existe o crond, responsável pelas suas tarefas agendadas presentes nos cronjobs, e esse cara tem um ponto interessante, pois se pensarmos de uma forma direta, ele executa tarefas que criamos e pedimos para rodar em determinados momentos ou de tanto em tanto tempo e quando não rodam eles ficam parados, muito semelhante aos próprios daemons! Seria então meus schedulers daemons também? A linha pode ser tênue, pois compartilham características. A principal dife","date":"2025-08-08","objectID":"/posts/deamons_d/:1:0","series":null,"tags":null,"title":"Daemons","uri":"/posts/deamons_d/#daemons-da-física--ao-controle-de-sistemas-linux"},{"categories":null,"content":" Hands On - SystemdBom vimos e embora eu ache muito legal a ideia, vamos com um pouco de pratica agora. Fica aqui o alerta, que vou tratar apenas de systemd nesse hands On, nada contra as demais formas de criar um deamon, é apenas pela praticidade e visualização que teremos. Antes de colocar a mão na massa e criar algum deamon, vamos analisar alguns ja existentes dentro de um pequeno lab, entao bora lá. ","date":"2025-08-08","objectID":"/posts/deamons_d/:2:0","series":null,"tags":null,"title":"Daemons","uri":"/posts/deamons_d/#hands-on---systemd"},{"categories":null,"content":" Lab:","date":"2025-08-08","objectID":"/posts/deamons_d/:2:1","series":null,"tags":null,"title":"Daemons","uri":"/posts/deamons_d/#lab"},{"categories":null,"content":" Laboratório de Troubleshooting com Systemd e JournalA ideia nesse lab é a gente exercitar como seria criar um daemons usando o systemd e fazer troubleshooting usando journalctl e o proprio systemd Parte 1: 1.Crie um script simples que servirá como nosso serviço bash sudo vi /usr/local/bin/meu-servico.sh E dentro do servico vamos adicionar um pequeno loop feito com bash. bash #!/bin/bash echo \"Iniciando meu-servico\" logger \"meu-servico iniciado\" count=1 while true; do echo \"meu-servico está funcionando: iteração $count\" logger \"meu-servico está rodando: verificação #$count\" count=$((count+1)) sleep 15 done OBS: pode ser qualquer conteudo mas caso queira algo pronto pode usar esse. 2.Agora vamos permitir que esse servico rode bash sudo chmod +x /usr/local/bin/meu-servico.sh 3.Beleza, se tudo certo até aqui, agora vamos criar um arquivo de config do systemd para o serviço bash sudo vi /etc/systemd/system/meu-servico.service Adicione o seguinte conteúdo: ini [Unit] Description=Meu servico de teste After=network.target [Service] Type=simple ExecStart=/usr/local/bin/meu-servico.sh Restart=always RestartSec=5 StandardOutput=journal StandardError=journal SyslogIdentifier=meu-servico [Install] WantedBy=multi-user.target 4.Ok, agora vamos iniciar tudo. Pra isso seguimos esse passo a passo: bash sudo systemctl daemon-reload sudo systemctl enable meu-servico.service sudo systemctl start meu-servico.service 5Pra verificar se o serviço está funcionando corretamente, podemos executar o seguinte comando: bash sudo systemctl status meu-servico.service Se ver um running, parabéns ta feito o nosso primeiro deamon usando systemd. 6.Agora vamos verificar os logs do nosso servico bash sudo journalctl -u meu-servico.service -f O parâmetro -f (follow) mostra as mensagens em tempo real. Parte 2:Ah beleza, nosso deamon rodando tudo certo e tudo na paz, mas ta na hora de quebrar tudo… Vamos quebrar o serviço de várias maneiras para praticar troubleshooting. Cenário 1: Corromper o script do serviçoBora acessar o codigo do scrit novamente bash sudo vi /usr/local/bin/meu-servico.sh Vamos inserir um erro de sintaxe qualquer: Reinicie o serviço: bash sudo systemctl restart meu-servico.service Cenário 2: Modificar as permissões do script bash sudo chmod -x /usr/local/bin/meu-servico.sh sudo systemctl restart meu-servico.service Parte 3:Agora vamos usar as ferramentas do systemd e journal para diagnosticar os problemas. 1. Verificar status do serviço bash sudo systemctl status meu-servico.service Observe os códigos de erro, mensagens e status. bash # Ver todos os logs do serviço sudo journalctl -u meu-servico.service # Ver apenas os logs de erro sudo journalctl -u meu-servico.service -p err # Ver logs de um período específico sudo journalctl -u meu-servico.service --since \"10 minutes ago\" # Ver logs do boot atual sudo journalctl -u meu-servico.service -b # Verificar dependências do serviço sudo systemctl list-dependencies meu-servico.service # Verificar configuração do serviço sudo systemctl cat meu-servico.service # Verificar processos ps aux | grep meu-servico Todos esses comandos vão te ajudar no troubleshooting. Recomendo rodar eles e ver o que cada um faz, buscando pegar cada nuance. Agora tenta achar os erros dentro dos logs, quebra novamente (ou mais), corrige eles e reinicia o daemon. No fim a ideia é essa… Praticar para que se um dia tiver que fazer um e atuar nele, vai estar tudo show. ","date":"2025-08-08","objectID":"/posts/deamons_d/:2:2","series":null,"tags":null,"title":"Daemons","uri":"/posts/deamons_d/#laboratório-de-troubleshooting-com-systemd-e-journal"},{"categories":null,"content":" Laboratório de Troubleshooting com Systemd e JournalA ideia nesse lab é a gente exercitar como seria criar um daemons usando o systemd e fazer troubleshooting usando journalctl e o proprio systemd Parte 1: 1.Crie um script simples que servirá como nosso serviço bash sudo vi /usr/local/bin/meu-servico.sh E dentro do servico vamos adicionar um pequeno loop feito com bash. bash #!/bin/bash echo \"Iniciando meu-servico\" logger \"meu-servico iniciado\" count=1 while true; do echo \"meu-servico está funcionando: iteração $count\" logger \"meu-servico está rodando: verificação #$count\" count=$((count+1)) sleep 15 done OBS: pode ser qualquer conteudo mas caso queira algo pronto pode usar esse. 2.Agora vamos permitir que esse servico rode bash sudo chmod +x /usr/local/bin/meu-servico.sh 3.Beleza, se tudo certo até aqui, agora vamos criar um arquivo de config do systemd para o serviço bash sudo vi /etc/systemd/system/meu-servico.service Adicione o seguinte conteúdo: ini [Unit] Description=Meu servico de teste After=network.target [Service] Type=simple ExecStart=/usr/local/bin/meu-servico.sh Restart=always RestartSec=5 StandardOutput=journal StandardError=journal SyslogIdentifier=meu-servico [Install] WantedBy=multi-user.target 4.Ok, agora vamos iniciar tudo. Pra isso seguimos esse passo a passo: bash sudo systemctl daemon-reload sudo systemctl enable meu-servico.service sudo systemctl start meu-servico.service 5Pra verificar se o serviço está funcionando corretamente, podemos executar o seguinte comando: bash sudo systemctl status meu-servico.service Se ver um running, parabéns ta feito o nosso primeiro deamon usando systemd. 6.Agora vamos verificar os logs do nosso servico bash sudo journalctl -u meu-servico.service -f O parâmetro -f (follow) mostra as mensagens em tempo real. Parte 2:Ah beleza, nosso deamon rodando tudo certo e tudo na paz, mas ta na hora de quebrar tudo… Vamos quebrar o serviço de várias maneiras para praticar troubleshooting. Cenário 1: Corromper o script do serviçoBora acessar o codigo do scrit novamente bash sudo vi /usr/local/bin/meu-servico.sh Vamos inserir um erro de sintaxe qualquer: Reinicie o serviço: bash sudo systemctl restart meu-servico.service Cenário 2: Modificar as permissões do script bash sudo chmod -x /usr/local/bin/meu-servico.sh sudo systemctl restart meu-servico.service Parte 3:Agora vamos usar as ferramentas do systemd e journal para diagnosticar os problemas. 1. Verificar status do serviço bash sudo systemctl status meu-servico.service Observe os códigos de erro, mensagens e status. bash # Ver todos os logs do serviço sudo journalctl -u meu-servico.service # Ver apenas os logs de erro sudo journalctl -u meu-servico.service -p err # Ver logs de um período específico sudo journalctl -u meu-servico.service --since \"10 minutes ago\" # Ver logs do boot atual sudo journalctl -u meu-servico.service -b # Verificar dependências do serviço sudo systemctl list-dependencies meu-servico.service # Verificar configuração do serviço sudo systemctl cat meu-servico.service # Verificar processos ps aux | grep meu-servico Todos esses comandos vão te ajudar no troubleshooting. Recomendo rodar eles e ver o que cada um faz, buscando pegar cada nuance. Agora tenta achar os erros dentro dos logs, quebra novamente (ou mais), corrige eles e reinicia o daemon. No fim a ideia é essa… Praticar para que se um dia tiver que fazer um e atuar nele, vai estar tudo show. ","date":"2025-08-08","objectID":"/posts/deamons_d/:2:2","series":null,"tags":null,"title":"Daemons","uri":"/posts/deamons_d/#parte-1"},{"categories":null,"content":" Laboratório de Troubleshooting com Systemd e JournalA ideia nesse lab é a gente exercitar como seria criar um daemons usando o systemd e fazer troubleshooting usando journalctl e o proprio systemd Parte 1: 1.Crie um script simples que servirá como nosso serviço bash sudo vi /usr/local/bin/meu-servico.sh E dentro do servico vamos adicionar um pequeno loop feito com bash. bash #!/bin/bash echo \"Iniciando meu-servico\" logger \"meu-servico iniciado\" count=1 while true; do echo \"meu-servico está funcionando: iteração $count\" logger \"meu-servico está rodando: verificação #$count\" count=$((count+1)) sleep 15 done OBS: pode ser qualquer conteudo mas caso queira algo pronto pode usar esse. 2.Agora vamos permitir que esse servico rode bash sudo chmod +x /usr/local/bin/meu-servico.sh 3.Beleza, se tudo certo até aqui, agora vamos criar um arquivo de config do systemd para o serviço bash sudo vi /etc/systemd/system/meu-servico.service Adicione o seguinte conteúdo: ini [Unit] Description=Meu servico de teste After=network.target [Service] Type=simple ExecStart=/usr/local/bin/meu-servico.sh Restart=always RestartSec=5 StandardOutput=journal StandardError=journal SyslogIdentifier=meu-servico [Install] WantedBy=multi-user.target 4.Ok, agora vamos iniciar tudo. Pra isso seguimos esse passo a passo: bash sudo systemctl daemon-reload sudo systemctl enable meu-servico.service sudo systemctl start meu-servico.service 5Pra verificar se o serviço está funcionando corretamente, podemos executar o seguinte comando: bash sudo systemctl status meu-servico.service Se ver um running, parabéns ta feito o nosso primeiro deamon usando systemd. 6.Agora vamos verificar os logs do nosso servico bash sudo journalctl -u meu-servico.service -f O parâmetro -f (follow) mostra as mensagens em tempo real. Parte 2:Ah beleza, nosso deamon rodando tudo certo e tudo na paz, mas ta na hora de quebrar tudo… Vamos quebrar o serviço de várias maneiras para praticar troubleshooting. Cenário 1: Corromper o script do serviçoBora acessar o codigo do scrit novamente bash sudo vi /usr/local/bin/meu-servico.sh Vamos inserir um erro de sintaxe qualquer: Reinicie o serviço: bash sudo systemctl restart meu-servico.service Cenário 2: Modificar as permissões do script bash sudo chmod -x /usr/local/bin/meu-servico.sh sudo systemctl restart meu-servico.service Parte 3:Agora vamos usar as ferramentas do systemd e journal para diagnosticar os problemas. 1. Verificar status do serviço bash sudo systemctl status meu-servico.service Observe os códigos de erro, mensagens e status. bash # Ver todos os logs do serviço sudo journalctl -u meu-servico.service # Ver apenas os logs de erro sudo journalctl -u meu-servico.service -p err # Ver logs de um período específico sudo journalctl -u meu-servico.service --since \"10 minutes ago\" # Ver logs do boot atual sudo journalctl -u meu-servico.service -b # Verificar dependências do serviço sudo systemctl list-dependencies meu-servico.service # Verificar configuração do serviço sudo systemctl cat meu-servico.service # Verificar processos ps aux | grep meu-servico Todos esses comandos vão te ajudar no troubleshooting. Recomendo rodar eles e ver o que cada um faz, buscando pegar cada nuance. Agora tenta achar os erros dentro dos logs, quebra novamente (ou mais), corrige eles e reinicia o daemon. No fim a ideia é essa… Praticar para que se um dia tiver que fazer um e atuar nele, vai estar tudo show. ","date":"2025-08-08","objectID":"/posts/deamons_d/:2:2","series":null,"tags":null,"title":"Daemons","uri":"/posts/deamons_d/#1"},{"categories":null,"content":" Laboratório de Troubleshooting com Systemd e JournalA ideia nesse lab é a gente exercitar como seria criar um daemons usando o systemd e fazer troubleshooting usando journalctl e o proprio systemd Parte 1: 1.Crie um script simples que servirá como nosso serviço bash sudo vi /usr/local/bin/meu-servico.sh E dentro do servico vamos adicionar um pequeno loop feito com bash. bash #!/bin/bash echo \"Iniciando meu-servico\" logger \"meu-servico iniciado\" count=1 while true; do echo \"meu-servico está funcionando: iteração $count\" logger \"meu-servico está rodando: verificação #$count\" count=$((count+1)) sleep 15 done OBS: pode ser qualquer conteudo mas caso queira algo pronto pode usar esse. 2.Agora vamos permitir que esse servico rode bash sudo chmod +x /usr/local/bin/meu-servico.sh 3.Beleza, se tudo certo até aqui, agora vamos criar um arquivo de config do systemd para o serviço bash sudo vi /etc/systemd/system/meu-servico.service Adicione o seguinte conteúdo: ini [Unit] Description=Meu servico de teste After=network.target [Service] Type=simple ExecStart=/usr/local/bin/meu-servico.sh Restart=always RestartSec=5 StandardOutput=journal StandardError=journal SyslogIdentifier=meu-servico [Install] WantedBy=multi-user.target 4.Ok, agora vamos iniciar tudo. Pra isso seguimos esse passo a passo: bash sudo systemctl daemon-reload sudo systemctl enable meu-servico.service sudo systemctl start meu-servico.service 5Pra verificar se o serviço está funcionando corretamente, podemos executar o seguinte comando: bash sudo systemctl status meu-servico.service Se ver um running, parabéns ta feito o nosso primeiro deamon usando systemd. 6.Agora vamos verificar os logs do nosso servico bash sudo journalctl -u meu-servico.service -f O parâmetro -f (follow) mostra as mensagens em tempo real. Parte 2:Ah beleza, nosso deamon rodando tudo certo e tudo na paz, mas ta na hora de quebrar tudo… Vamos quebrar o serviço de várias maneiras para praticar troubleshooting. Cenário 1: Corromper o script do serviçoBora acessar o codigo do scrit novamente bash sudo vi /usr/local/bin/meu-servico.sh Vamos inserir um erro de sintaxe qualquer: Reinicie o serviço: bash sudo systemctl restart meu-servico.service Cenário 2: Modificar as permissões do script bash sudo chmod -x /usr/local/bin/meu-servico.sh sudo systemctl restart meu-servico.service Parte 3:Agora vamos usar as ferramentas do systemd e journal para diagnosticar os problemas. 1. Verificar status do serviço bash sudo systemctl status meu-servico.service Observe os códigos de erro, mensagens e status. bash # Ver todos os logs do serviço sudo journalctl -u meu-servico.service # Ver apenas os logs de erro sudo journalctl -u meu-servico.service -p err # Ver logs de um período específico sudo journalctl -u meu-servico.service --since \"10 minutes ago\" # Ver logs do boot atual sudo journalctl -u meu-servico.service -b # Verificar dependências do serviço sudo systemctl list-dependencies meu-servico.service # Verificar configuração do serviço sudo systemctl cat meu-servico.service # Verificar processos ps aux | grep meu-servico Todos esses comandos vão te ajudar no troubleshooting. Recomendo rodar eles e ver o que cada um faz, buscando pegar cada nuance. Agora tenta achar os erros dentro dos logs, quebra novamente (ou mais), corrige eles e reinicia o daemon. No fim a ideia é essa… Praticar para que se um dia tiver que fazer um e atuar nele, vai estar tudo show. ","date":"2025-08-08","objectID":"/posts/deamons_d/:2:2","series":null,"tags":null,"title":"Daemons","uri":"/posts/deamons_d/#2"},{"categories":null,"content":" Laboratório de Troubleshooting com Systemd e JournalA ideia nesse lab é a gente exercitar como seria criar um daemons usando o systemd e fazer troubleshooting usando journalctl e o proprio systemd Parte 1: 1.Crie um script simples que servirá como nosso serviço bash sudo vi /usr/local/bin/meu-servico.sh E dentro do servico vamos adicionar um pequeno loop feito com bash. bash #!/bin/bash echo \"Iniciando meu-servico\" logger \"meu-servico iniciado\" count=1 while true; do echo \"meu-servico está funcionando: iteração $count\" logger \"meu-servico está rodando: verificação #$count\" count=$((count+1)) sleep 15 done OBS: pode ser qualquer conteudo mas caso queira algo pronto pode usar esse. 2.Agora vamos permitir que esse servico rode bash sudo chmod +x /usr/local/bin/meu-servico.sh 3.Beleza, se tudo certo até aqui, agora vamos criar um arquivo de config do systemd para o serviço bash sudo vi /etc/systemd/system/meu-servico.service Adicione o seguinte conteúdo: ini [Unit] Description=Meu servico de teste After=network.target [Service] Type=simple ExecStart=/usr/local/bin/meu-servico.sh Restart=always RestartSec=5 StandardOutput=journal StandardError=journal SyslogIdentifier=meu-servico [Install] WantedBy=multi-user.target 4.Ok, agora vamos iniciar tudo. Pra isso seguimos esse passo a passo: bash sudo systemctl daemon-reload sudo systemctl enable meu-servico.service sudo systemctl start meu-servico.service 5Pra verificar se o serviço está funcionando corretamente, podemos executar o seguinte comando: bash sudo systemctl status meu-servico.service Se ver um running, parabéns ta feito o nosso primeiro deamon usando systemd. 6.Agora vamos verificar os logs do nosso servico bash sudo journalctl -u meu-servico.service -f O parâmetro -f (follow) mostra as mensagens em tempo real. Parte 2:Ah beleza, nosso deamon rodando tudo certo e tudo na paz, mas ta na hora de quebrar tudo… Vamos quebrar o serviço de várias maneiras para praticar troubleshooting. Cenário 1: Corromper o script do serviçoBora acessar o codigo do scrit novamente bash sudo vi /usr/local/bin/meu-servico.sh Vamos inserir um erro de sintaxe qualquer: Reinicie o serviço: bash sudo systemctl restart meu-servico.service Cenário 2: Modificar as permissões do script bash sudo chmod -x /usr/local/bin/meu-servico.sh sudo systemctl restart meu-servico.service Parte 3:Agora vamos usar as ferramentas do systemd e journal para diagnosticar os problemas. 1. Verificar status do serviço bash sudo systemctl status meu-servico.service Observe os códigos de erro, mensagens e status. bash # Ver todos os logs do serviço sudo journalctl -u meu-servico.service # Ver apenas os logs de erro sudo journalctl -u meu-servico.service -p err # Ver logs de um período específico sudo journalctl -u meu-servico.service --since \"10 minutes ago\" # Ver logs do boot atual sudo journalctl -u meu-servico.service -b # Verificar dependências do serviço sudo systemctl list-dependencies meu-servico.service # Verificar configuração do serviço sudo systemctl cat meu-servico.service # Verificar processos ps aux | grep meu-servico Todos esses comandos vão te ajudar no troubleshooting. Recomendo rodar eles e ver o que cada um faz, buscando pegar cada nuance. Agora tenta achar os erros dentro dos logs, quebra novamente (ou mais), corrige eles e reinicia o daemon. No fim a ideia é essa… Praticar para que se um dia tiver que fazer um e atuar nele, vai estar tudo show. ","date":"2025-08-08","objectID":"/posts/deamons_d/:2:2","series":null,"tags":null,"title":"Daemons","uri":"/posts/deamons_d/#3"},{"categories":null,"content":" Laboratório de Troubleshooting com Systemd e JournalA ideia nesse lab é a gente exercitar como seria criar um daemons usando o systemd e fazer troubleshooting usando journalctl e o proprio systemd Parte 1: 1.Crie um script simples que servirá como nosso serviço bash sudo vi /usr/local/bin/meu-servico.sh E dentro do servico vamos adicionar um pequeno loop feito com bash. bash #!/bin/bash echo \"Iniciando meu-servico\" logger \"meu-servico iniciado\" count=1 while true; do echo \"meu-servico está funcionando: iteração $count\" logger \"meu-servico está rodando: verificação #$count\" count=$((count+1)) sleep 15 done OBS: pode ser qualquer conteudo mas caso queira algo pronto pode usar esse. 2.Agora vamos permitir que esse servico rode bash sudo chmod +x /usr/local/bin/meu-servico.sh 3.Beleza, se tudo certo até aqui, agora vamos criar um arquivo de config do systemd para o serviço bash sudo vi /etc/systemd/system/meu-servico.service Adicione o seguinte conteúdo: ini [Unit] Description=Meu servico de teste After=network.target [Service] Type=simple ExecStart=/usr/local/bin/meu-servico.sh Restart=always RestartSec=5 StandardOutput=journal StandardError=journal SyslogIdentifier=meu-servico [Install] WantedBy=multi-user.target 4.Ok, agora vamos iniciar tudo. Pra isso seguimos esse passo a passo: bash sudo systemctl daemon-reload sudo systemctl enable meu-servico.service sudo systemctl start meu-servico.service 5Pra verificar se o serviço está funcionando corretamente, podemos executar o seguinte comando: bash sudo systemctl status meu-servico.service Se ver um running, parabéns ta feito o nosso primeiro deamon usando systemd. 6.Agora vamos verificar os logs do nosso servico bash sudo journalctl -u meu-servico.service -f O parâmetro -f (follow) mostra as mensagens em tempo real. Parte 2:Ah beleza, nosso deamon rodando tudo certo e tudo na paz, mas ta na hora de quebrar tudo… Vamos quebrar o serviço de várias maneiras para praticar troubleshooting. Cenário 1: Corromper o script do serviçoBora acessar o codigo do scrit novamente bash sudo vi /usr/local/bin/meu-servico.sh Vamos inserir um erro de sintaxe qualquer: Reinicie o serviço: bash sudo systemctl restart meu-servico.service Cenário 2: Modificar as permissões do script bash sudo chmod -x /usr/local/bin/meu-servico.sh sudo systemctl restart meu-servico.service Parte 3:Agora vamos usar as ferramentas do systemd e journal para diagnosticar os problemas. 1. Verificar status do serviço bash sudo systemctl status meu-servico.service Observe os códigos de erro, mensagens e status. bash # Ver todos os logs do serviço sudo journalctl -u meu-servico.service # Ver apenas os logs de erro sudo journalctl -u meu-servico.service -p err # Ver logs de um período específico sudo journalctl -u meu-servico.service --since \"10 minutes ago\" # Ver logs do boot atual sudo journalctl -u meu-servico.service -b # Verificar dependências do serviço sudo systemctl list-dependencies meu-servico.service # Verificar configuração do serviço sudo systemctl cat meu-servico.service # Verificar processos ps aux | grep meu-servico Todos esses comandos vão te ajudar no troubleshooting. Recomendo rodar eles e ver o que cada um faz, buscando pegar cada nuance. Agora tenta achar os erros dentro dos logs, quebra novamente (ou mais), corrige eles e reinicia o daemon. No fim a ideia é essa… Praticar para que se um dia tiver que fazer um e atuar nele, vai estar tudo show. ","date":"2025-08-08","objectID":"/posts/deamons_d/:2:2","series":null,"tags":null,"title":"Daemons","uri":"/posts/deamons_d/#4"},{"categories":null,"content":" Laboratório de Troubleshooting com Systemd e JournalA ideia nesse lab é a gente exercitar como seria criar um daemons usando o systemd e fazer troubleshooting usando journalctl e o proprio systemd Parte 1: 1.Crie um script simples que servirá como nosso serviço bash sudo vi /usr/local/bin/meu-servico.sh E dentro do servico vamos adicionar um pequeno loop feito com bash. bash #!/bin/bash echo \"Iniciando meu-servico\" logger \"meu-servico iniciado\" count=1 while true; do echo \"meu-servico está funcionando: iteração $count\" logger \"meu-servico está rodando: verificação #$count\" count=$((count+1)) sleep 15 done OBS: pode ser qualquer conteudo mas caso queira algo pronto pode usar esse. 2.Agora vamos permitir que esse servico rode bash sudo chmod +x /usr/local/bin/meu-servico.sh 3.Beleza, se tudo certo até aqui, agora vamos criar um arquivo de config do systemd para o serviço bash sudo vi /etc/systemd/system/meu-servico.service Adicione o seguinte conteúdo: ini [Unit] Description=Meu servico de teste After=network.target [Service] Type=simple ExecStart=/usr/local/bin/meu-servico.sh Restart=always RestartSec=5 StandardOutput=journal StandardError=journal SyslogIdentifier=meu-servico [Install] WantedBy=multi-user.target 4.Ok, agora vamos iniciar tudo. Pra isso seguimos esse passo a passo: bash sudo systemctl daemon-reload sudo systemctl enable meu-servico.service sudo systemctl start meu-servico.service 5Pra verificar se o serviço está funcionando corretamente, podemos executar o seguinte comando: bash sudo systemctl status meu-servico.service Se ver um running, parabéns ta feito o nosso primeiro deamon usando systemd. 6.Agora vamos verificar os logs do nosso servico bash sudo journalctl -u meu-servico.service -f O parâmetro -f (follow) mostra as mensagens em tempo real. Parte 2:Ah beleza, nosso deamon rodando tudo certo e tudo na paz, mas ta na hora de quebrar tudo… Vamos quebrar o serviço de várias maneiras para praticar troubleshooting. Cenário 1: Corromper o script do serviçoBora acessar o codigo do scrit novamente bash sudo vi /usr/local/bin/meu-servico.sh Vamos inserir um erro de sintaxe qualquer: Reinicie o serviço: bash sudo systemctl restart meu-servico.service Cenário 2: Modificar as permissões do script bash sudo chmod -x /usr/local/bin/meu-servico.sh sudo systemctl restart meu-servico.service Parte 3:Agora vamos usar as ferramentas do systemd e journal para diagnosticar os problemas. 1. Verificar status do serviço bash sudo systemctl status meu-servico.service Observe os códigos de erro, mensagens e status. bash # Ver todos os logs do serviço sudo journalctl -u meu-servico.service # Ver apenas os logs de erro sudo journalctl -u meu-servico.service -p err # Ver logs de um período específico sudo journalctl -u meu-servico.service --since \"10 minutes ago\" # Ver logs do boot atual sudo journalctl -u meu-servico.service -b # Verificar dependências do serviço sudo systemctl list-dependencies meu-servico.service # Verificar configuração do serviço sudo systemctl cat meu-servico.service # Verificar processos ps aux | grep meu-servico Todos esses comandos vão te ajudar no troubleshooting. Recomendo rodar eles e ver o que cada um faz, buscando pegar cada nuance. Agora tenta achar os erros dentro dos logs, quebra novamente (ou mais), corrige eles e reinicia o daemon. No fim a ideia é essa… Praticar para que se um dia tiver que fazer um e atuar nele, vai estar tudo show. ","date":"2025-08-08","objectID":"/posts/deamons_d/:2:2","series":null,"tags":null,"title":"Daemons","uri":"/posts/deamons_d/#5"},{"categories":null,"content":" Laboratório de Troubleshooting com Systemd e JournalA ideia nesse lab é a gente exercitar como seria criar um daemons usando o systemd e fazer troubleshooting usando journalctl e o proprio systemd Parte 1: 1.Crie um script simples que servirá como nosso serviço bash sudo vi /usr/local/bin/meu-servico.sh E dentro do servico vamos adicionar um pequeno loop feito com bash. bash #!/bin/bash echo \"Iniciando meu-servico\" logger \"meu-servico iniciado\" count=1 while true; do echo \"meu-servico está funcionando: iteração $count\" logger \"meu-servico está rodando: verificação #$count\" count=$((count+1)) sleep 15 done OBS: pode ser qualquer conteudo mas caso queira algo pronto pode usar esse. 2.Agora vamos permitir que esse servico rode bash sudo chmod +x /usr/local/bin/meu-servico.sh 3.Beleza, se tudo certo até aqui, agora vamos criar um arquivo de config do systemd para o serviço bash sudo vi /etc/systemd/system/meu-servico.service Adicione o seguinte conteúdo: ini [Unit] Description=Meu servico de teste After=network.target [Service] Type=simple ExecStart=/usr/local/bin/meu-servico.sh Restart=always RestartSec=5 StandardOutput=journal StandardError=journal SyslogIdentifier=meu-servico [Install] WantedBy=multi-user.target 4.Ok, agora vamos iniciar tudo. Pra isso seguimos esse passo a passo: bash sudo systemctl daemon-reload sudo systemctl enable meu-servico.service sudo systemctl start meu-servico.service 5Pra verificar se o serviço está funcionando corretamente, podemos executar o seguinte comando: bash sudo systemctl status meu-servico.service Se ver um running, parabéns ta feito o nosso primeiro deamon usando systemd. 6.Agora vamos verificar os logs do nosso servico bash sudo journalctl -u meu-servico.service -f O parâmetro -f (follow) mostra as mensagens em tempo real. Parte 2:Ah beleza, nosso deamon rodando tudo certo e tudo na paz, mas ta na hora de quebrar tudo… Vamos quebrar o serviço de várias maneiras para praticar troubleshooting. Cenário 1: Corromper o script do serviçoBora acessar o codigo do scrit novamente bash sudo vi /usr/local/bin/meu-servico.sh Vamos inserir um erro de sintaxe qualquer: Reinicie o serviço: bash sudo systemctl restart meu-servico.service Cenário 2: Modificar as permissões do script bash sudo chmod -x /usr/local/bin/meu-servico.sh sudo systemctl restart meu-servico.service Parte 3:Agora vamos usar as ferramentas do systemd e journal para diagnosticar os problemas. 1. Verificar status do serviço bash sudo systemctl status meu-servico.service Observe os códigos de erro, mensagens e status. bash # Ver todos os logs do serviço sudo journalctl -u meu-servico.service # Ver apenas os logs de erro sudo journalctl -u meu-servico.service -p err # Ver logs de um período específico sudo journalctl -u meu-servico.service --since \"10 minutes ago\" # Ver logs do boot atual sudo journalctl -u meu-servico.service -b # Verificar dependências do serviço sudo systemctl list-dependencies meu-servico.service # Verificar configuração do serviço sudo systemctl cat meu-servico.service # Verificar processos ps aux | grep meu-servico Todos esses comandos vão te ajudar no troubleshooting. Recomendo rodar eles e ver o que cada um faz, buscando pegar cada nuance. Agora tenta achar os erros dentro dos logs, quebra novamente (ou mais), corrige eles e reinicia o daemon. No fim a ideia é essa… Praticar para que se um dia tiver que fazer um e atuar nele, vai estar tudo show. ","date":"2025-08-08","objectID":"/posts/deamons_d/:2:2","series":null,"tags":null,"title":"Daemons","uri":"/posts/deamons_d/#6"},{"categories":null,"content":" Laboratório de Troubleshooting com Systemd e JournalA ideia nesse lab é a gente exercitar como seria criar um daemons usando o systemd e fazer troubleshooting usando journalctl e o proprio systemd Parte 1: 1.Crie um script simples que servirá como nosso serviço bash sudo vi /usr/local/bin/meu-servico.sh E dentro do servico vamos adicionar um pequeno loop feito com bash. bash #!/bin/bash echo \"Iniciando meu-servico\" logger \"meu-servico iniciado\" count=1 while true; do echo \"meu-servico está funcionando: iteração $count\" logger \"meu-servico está rodando: verificação #$count\" count=$((count+1)) sleep 15 done OBS: pode ser qualquer conteudo mas caso queira algo pronto pode usar esse. 2.Agora vamos permitir que esse servico rode bash sudo chmod +x /usr/local/bin/meu-servico.sh 3.Beleza, se tudo certo até aqui, agora vamos criar um arquivo de config do systemd para o serviço bash sudo vi /etc/systemd/system/meu-servico.service Adicione o seguinte conteúdo: ini [Unit] Description=Meu servico de teste After=network.target [Service] Type=simple ExecStart=/usr/local/bin/meu-servico.sh Restart=always RestartSec=5 StandardOutput=journal StandardError=journal SyslogIdentifier=meu-servico [Install] WantedBy=multi-user.target 4.Ok, agora vamos iniciar tudo. Pra isso seguimos esse passo a passo: bash sudo systemctl daemon-reload sudo systemctl enable meu-servico.service sudo systemctl start meu-servico.service 5Pra verificar se o serviço está funcionando corretamente, podemos executar o seguinte comando: bash sudo systemctl status meu-servico.service Se ver um running, parabéns ta feito o nosso primeiro deamon usando systemd. 6.Agora vamos verificar os logs do nosso servico bash sudo journalctl -u meu-servico.service -f O parâmetro -f (follow) mostra as mensagens em tempo real. Parte 2:Ah beleza, nosso deamon rodando tudo certo e tudo na paz, mas ta na hora de quebrar tudo… Vamos quebrar o serviço de várias maneiras para praticar troubleshooting. Cenário 1: Corromper o script do serviçoBora acessar o codigo do scrit novamente bash sudo vi /usr/local/bin/meu-servico.sh Vamos inserir um erro de sintaxe qualquer: Reinicie o serviço: bash sudo systemctl restart meu-servico.service Cenário 2: Modificar as permissões do script bash sudo chmod -x /usr/local/bin/meu-servico.sh sudo systemctl restart meu-servico.service Parte 3:Agora vamos usar as ferramentas do systemd e journal para diagnosticar os problemas. 1. Verificar status do serviço bash sudo systemctl status meu-servico.service Observe os códigos de erro, mensagens e status. bash # Ver todos os logs do serviço sudo journalctl -u meu-servico.service # Ver apenas os logs de erro sudo journalctl -u meu-servico.service -p err # Ver logs de um período específico sudo journalctl -u meu-servico.service --since \"10 minutes ago\" # Ver logs do boot atual sudo journalctl -u meu-servico.service -b # Verificar dependências do serviço sudo systemctl list-dependencies meu-servico.service # Verificar configuração do serviço sudo systemctl cat meu-servico.service # Verificar processos ps aux | grep meu-servico Todos esses comandos vão te ajudar no troubleshooting. Recomendo rodar eles e ver o que cada um faz, buscando pegar cada nuance. Agora tenta achar os erros dentro dos logs, quebra novamente (ou mais), corrige eles e reinicia o daemon. No fim a ideia é essa… Praticar para que se um dia tiver que fazer um e atuar nele, vai estar tudo show. ","date":"2025-08-08","objectID":"/posts/deamons_d/:2:2","series":null,"tags":null,"title":"Daemons","uri":"/posts/deamons_d/#parte-2"},{"categories":null,"content":" Laboratório de Troubleshooting com Systemd e JournalA ideia nesse lab é a gente exercitar como seria criar um daemons usando o systemd e fazer troubleshooting usando journalctl e o proprio systemd Parte 1: 1.Crie um script simples que servirá como nosso serviço bash sudo vi /usr/local/bin/meu-servico.sh E dentro do servico vamos adicionar um pequeno loop feito com bash. bash #!/bin/bash echo \"Iniciando meu-servico\" logger \"meu-servico iniciado\" count=1 while true; do echo \"meu-servico está funcionando: iteração $count\" logger \"meu-servico está rodando: verificação #$count\" count=$((count+1)) sleep 15 done OBS: pode ser qualquer conteudo mas caso queira algo pronto pode usar esse. 2.Agora vamos permitir que esse servico rode bash sudo chmod +x /usr/local/bin/meu-servico.sh 3.Beleza, se tudo certo até aqui, agora vamos criar um arquivo de config do systemd para o serviço bash sudo vi /etc/systemd/system/meu-servico.service Adicione o seguinte conteúdo: ini [Unit] Description=Meu servico de teste After=network.target [Service] Type=simple ExecStart=/usr/local/bin/meu-servico.sh Restart=always RestartSec=5 StandardOutput=journal StandardError=journal SyslogIdentifier=meu-servico [Install] WantedBy=multi-user.target 4.Ok, agora vamos iniciar tudo. Pra isso seguimos esse passo a passo: bash sudo systemctl daemon-reload sudo systemctl enable meu-servico.service sudo systemctl start meu-servico.service 5Pra verificar se o serviço está funcionando corretamente, podemos executar o seguinte comando: bash sudo systemctl status meu-servico.service Se ver um running, parabéns ta feito o nosso primeiro deamon usando systemd. 6.Agora vamos verificar os logs do nosso servico bash sudo journalctl -u meu-servico.service -f O parâmetro -f (follow) mostra as mensagens em tempo real. Parte 2:Ah beleza, nosso deamon rodando tudo certo e tudo na paz, mas ta na hora de quebrar tudo… Vamos quebrar o serviço de várias maneiras para praticar troubleshooting. Cenário 1: Corromper o script do serviçoBora acessar o codigo do scrit novamente bash sudo vi /usr/local/bin/meu-servico.sh Vamos inserir um erro de sintaxe qualquer: Reinicie o serviço: bash sudo systemctl restart meu-servico.service Cenário 2: Modificar as permissões do script bash sudo chmod -x /usr/local/bin/meu-servico.sh sudo systemctl restart meu-servico.service Parte 3:Agora vamos usar as ferramentas do systemd e journal para diagnosticar os problemas. 1. Verificar status do serviço bash sudo systemctl status meu-servico.service Observe os códigos de erro, mensagens e status. bash # Ver todos os logs do serviço sudo journalctl -u meu-servico.service # Ver apenas os logs de erro sudo journalctl -u meu-servico.service -p err # Ver logs de um período específico sudo journalctl -u meu-servico.service --since \"10 minutes ago\" # Ver logs do boot atual sudo journalctl -u meu-servico.service -b # Verificar dependências do serviço sudo systemctl list-dependencies meu-servico.service # Verificar configuração do serviço sudo systemctl cat meu-servico.service # Verificar processos ps aux | grep meu-servico Todos esses comandos vão te ajudar no troubleshooting. Recomendo rodar eles e ver o que cada um faz, buscando pegar cada nuance. Agora tenta achar os erros dentro dos logs, quebra novamente (ou mais), corrige eles e reinicia o daemon. No fim a ideia é essa… Praticar para que se um dia tiver que fazer um e atuar nele, vai estar tudo show. ","date":"2025-08-08","objectID":"/posts/deamons_d/:2:2","series":null,"tags":null,"title":"Daemons","uri":"/posts/deamons_d/#cenário-1-corromper-o-script-do-serviço"},{"categories":null,"content":" Laboratório de Troubleshooting com Systemd e JournalA ideia nesse lab é a gente exercitar como seria criar um daemons usando o systemd e fazer troubleshooting usando journalctl e o proprio systemd Parte 1: 1.Crie um script simples que servirá como nosso serviço bash sudo vi /usr/local/bin/meu-servico.sh E dentro do servico vamos adicionar um pequeno loop feito com bash. bash #!/bin/bash echo \"Iniciando meu-servico\" logger \"meu-servico iniciado\" count=1 while true; do echo \"meu-servico está funcionando: iteração $count\" logger \"meu-servico está rodando: verificação #$count\" count=$((count+1)) sleep 15 done OBS: pode ser qualquer conteudo mas caso queira algo pronto pode usar esse. 2.Agora vamos permitir que esse servico rode bash sudo chmod +x /usr/local/bin/meu-servico.sh 3.Beleza, se tudo certo até aqui, agora vamos criar um arquivo de config do systemd para o serviço bash sudo vi /etc/systemd/system/meu-servico.service Adicione o seguinte conteúdo: ini [Unit] Description=Meu servico de teste After=network.target [Service] Type=simple ExecStart=/usr/local/bin/meu-servico.sh Restart=always RestartSec=5 StandardOutput=journal StandardError=journal SyslogIdentifier=meu-servico [Install] WantedBy=multi-user.target 4.Ok, agora vamos iniciar tudo. Pra isso seguimos esse passo a passo: bash sudo systemctl daemon-reload sudo systemctl enable meu-servico.service sudo systemctl start meu-servico.service 5Pra verificar se o serviço está funcionando corretamente, podemos executar o seguinte comando: bash sudo systemctl status meu-servico.service Se ver um running, parabéns ta feito o nosso primeiro deamon usando systemd. 6.Agora vamos verificar os logs do nosso servico bash sudo journalctl -u meu-servico.service -f O parâmetro -f (follow) mostra as mensagens em tempo real. Parte 2:Ah beleza, nosso deamon rodando tudo certo e tudo na paz, mas ta na hora de quebrar tudo… Vamos quebrar o serviço de várias maneiras para praticar troubleshooting. Cenário 1: Corromper o script do serviçoBora acessar o codigo do scrit novamente bash sudo vi /usr/local/bin/meu-servico.sh Vamos inserir um erro de sintaxe qualquer: Reinicie o serviço: bash sudo systemctl restart meu-servico.service Cenário 2: Modificar as permissões do script bash sudo chmod -x /usr/local/bin/meu-servico.sh sudo systemctl restart meu-servico.service Parte 3:Agora vamos usar as ferramentas do systemd e journal para diagnosticar os problemas. 1. Verificar status do serviço bash sudo systemctl status meu-servico.service Observe os códigos de erro, mensagens e status. bash # Ver todos os logs do serviço sudo journalctl -u meu-servico.service # Ver apenas os logs de erro sudo journalctl -u meu-servico.service -p err # Ver logs de um período específico sudo journalctl -u meu-servico.service --since \"10 minutes ago\" # Ver logs do boot atual sudo journalctl -u meu-servico.service -b # Verificar dependências do serviço sudo systemctl list-dependencies meu-servico.service # Verificar configuração do serviço sudo systemctl cat meu-servico.service # Verificar processos ps aux | grep meu-servico Todos esses comandos vão te ajudar no troubleshooting. Recomendo rodar eles e ver o que cada um faz, buscando pegar cada nuance. Agora tenta achar os erros dentro dos logs, quebra novamente (ou mais), corrige eles e reinicia o daemon. No fim a ideia é essa… Praticar para que se um dia tiver que fazer um e atuar nele, vai estar tudo show. ","date":"2025-08-08","objectID":"/posts/deamons_d/:2:2","series":null,"tags":null,"title":"Daemons","uri":"/posts/deamons_d/#cenário-2-modificar-as-permissões-do-script"},{"categories":null,"content":" Laboratório de Troubleshooting com Systemd e JournalA ideia nesse lab é a gente exercitar como seria criar um daemons usando o systemd e fazer troubleshooting usando journalctl e o proprio systemd Parte 1: 1.Crie um script simples que servirá como nosso serviço bash sudo vi /usr/local/bin/meu-servico.sh E dentro do servico vamos adicionar um pequeno loop feito com bash. bash #!/bin/bash echo \"Iniciando meu-servico\" logger \"meu-servico iniciado\" count=1 while true; do echo \"meu-servico está funcionando: iteração $count\" logger \"meu-servico está rodando: verificação #$count\" count=$((count+1)) sleep 15 done OBS: pode ser qualquer conteudo mas caso queira algo pronto pode usar esse. 2.Agora vamos permitir que esse servico rode bash sudo chmod +x /usr/local/bin/meu-servico.sh 3.Beleza, se tudo certo até aqui, agora vamos criar um arquivo de config do systemd para o serviço bash sudo vi /etc/systemd/system/meu-servico.service Adicione o seguinte conteúdo: ini [Unit] Description=Meu servico de teste After=network.target [Service] Type=simple ExecStart=/usr/local/bin/meu-servico.sh Restart=always RestartSec=5 StandardOutput=journal StandardError=journal SyslogIdentifier=meu-servico [Install] WantedBy=multi-user.target 4.Ok, agora vamos iniciar tudo. Pra isso seguimos esse passo a passo: bash sudo systemctl daemon-reload sudo systemctl enable meu-servico.service sudo systemctl start meu-servico.service 5Pra verificar se o serviço está funcionando corretamente, podemos executar o seguinte comando: bash sudo systemctl status meu-servico.service Se ver um running, parabéns ta feito o nosso primeiro deamon usando systemd. 6.Agora vamos verificar os logs do nosso servico bash sudo journalctl -u meu-servico.service -f O parâmetro -f (follow) mostra as mensagens em tempo real. Parte 2:Ah beleza, nosso deamon rodando tudo certo e tudo na paz, mas ta na hora de quebrar tudo… Vamos quebrar o serviço de várias maneiras para praticar troubleshooting. Cenário 1: Corromper o script do serviçoBora acessar o codigo do scrit novamente bash sudo vi /usr/local/bin/meu-servico.sh Vamos inserir um erro de sintaxe qualquer: Reinicie o serviço: bash sudo systemctl restart meu-servico.service Cenário 2: Modificar as permissões do script bash sudo chmod -x /usr/local/bin/meu-servico.sh sudo systemctl restart meu-servico.service Parte 3:Agora vamos usar as ferramentas do systemd e journal para diagnosticar os problemas. 1. Verificar status do serviço bash sudo systemctl status meu-servico.service Observe os códigos de erro, mensagens e status. bash # Ver todos os logs do serviço sudo journalctl -u meu-servico.service # Ver apenas os logs de erro sudo journalctl -u meu-servico.service -p err # Ver logs de um período específico sudo journalctl -u meu-servico.service --since \"10 minutes ago\" # Ver logs do boot atual sudo journalctl -u meu-servico.service -b # Verificar dependências do serviço sudo systemctl list-dependencies meu-servico.service # Verificar configuração do serviço sudo systemctl cat meu-servico.service # Verificar processos ps aux | grep meu-servico Todos esses comandos vão te ajudar no troubleshooting. Recomendo rodar eles e ver o que cada um faz, buscando pegar cada nuance. Agora tenta achar os erros dentro dos logs, quebra novamente (ou mais), corrige eles e reinicia o daemon. No fim a ideia é essa… Praticar para que se um dia tiver que fazer um e atuar nele, vai estar tudo show. ","date":"2025-08-08","objectID":"/posts/deamons_d/:2:2","series":null,"tags":null,"title":"Daemons","uri":"/posts/deamons_d/#parte-3"},{"categories":null,"content":" Laboratório de Troubleshooting com Systemd e JournalA ideia nesse lab é a gente exercitar como seria criar um daemons usando o systemd e fazer troubleshooting usando journalctl e o proprio systemd Parte 1: 1.Crie um script simples que servirá como nosso serviço bash sudo vi /usr/local/bin/meu-servico.sh E dentro do servico vamos adicionar um pequeno loop feito com bash. bash #!/bin/bash echo \"Iniciando meu-servico\" logger \"meu-servico iniciado\" count=1 while true; do echo \"meu-servico está funcionando: iteração $count\" logger \"meu-servico está rodando: verificação #$count\" count=$((count+1)) sleep 15 done OBS: pode ser qualquer conteudo mas caso queira algo pronto pode usar esse. 2.Agora vamos permitir que esse servico rode bash sudo chmod +x /usr/local/bin/meu-servico.sh 3.Beleza, se tudo certo até aqui, agora vamos criar um arquivo de config do systemd para o serviço bash sudo vi /etc/systemd/system/meu-servico.service Adicione o seguinte conteúdo: ini [Unit] Description=Meu servico de teste After=network.target [Service] Type=simple ExecStart=/usr/local/bin/meu-servico.sh Restart=always RestartSec=5 StandardOutput=journal StandardError=journal SyslogIdentifier=meu-servico [Install] WantedBy=multi-user.target 4.Ok, agora vamos iniciar tudo. Pra isso seguimos esse passo a passo: bash sudo systemctl daemon-reload sudo systemctl enable meu-servico.service sudo systemctl start meu-servico.service 5Pra verificar se o serviço está funcionando corretamente, podemos executar o seguinte comando: bash sudo systemctl status meu-servico.service Se ver um running, parabéns ta feito o nosso primeiro deamon usando systemd. 6.Agora vamos verificar os logs do nosso servico bash sudo journalctl -u meu-servico.service -f O parâmetro -f (follow) mostra as mensagens em tempo real. Parte 2:Ah beleza, nosso deamon rodando tudo certo e tudo na paz, mas ta na hora de quebrar tudo… Vamos quebrar o serviço de várias maneiras para praticar troubleshooting. Cenário 1: Corromper o script do serviçoBora acessar o codigo do scrit novamente bash sudo vi /usr/local/bin/meu-servico.sh Vamos inserir um erro de sintaxe qualquer: Reinicie o serviço: bash sudo systemctl restart meu-servico.service Cenário 2: Modificar as permissões do script bash sudo chmod -x /usr/local/bin/meu-servico.sh sudo systemctl restart meu-servico.service Parte 3:Agora vamos usar as ferramentas do systemd e journal para diagnosticar os problemas. 1. Verificar status do serviço bash sudo systemctl status meu-servico.service Observe os códigos de erro, mensagens e status. bash # Ver todos os logs do serviço sudo journalctl -u meu-servico.service # Ver apenas os logs de erro sudo journalctl -u meu-servico.service -p err # Ver logs de um período específico sudo journalctl -u meu-servico.service --since \"10 minutes ago\" # Ver logs do boot atual sudo journalctl -u meu-servico.service -b # Verificar dependências do serviço sudo systemctl list-dependencies meu-servico.service # Verificar configuração do serviço sudo systemctl cat meu-servico.service # Verificar processos ps aux | grep meu-servico Todos esses comandos vão te ajudar no troubleshooting. Recomendo rodar eles e ver o que cada um faz, buscando pegar cada nuance. Agora tenta achar os erros dentro dos logs, quebra novamente (ou mais), corrige eles e reinicia o daemon. No fim a ideia é essa… Praticar para que se um dia tiver que fazer um e atuar nele, vai estar tudo show. ","date":"2025-08-08","objectID":"/posts/deamons_d/:2:2","series":null,"tags":null,"title":"Daemons","uri":"/posts/deamons_d/#1-verificar-status-do-serviço"},{"categories":null,"content":" Over here, strangerOlá! Seja muito bem-vindo(a) ao meu blog. Criei este espaço como uma forma de documentar minha jornada, organizar ideias e compartilhar experiências vividas no dia a dia — seja estudando, desenvolvendo projetos, testando novas soluções ou simplesmente refletindo sobre tecnologia e seus impactos. ","date":"0001-01-01","objectID":"/about/:1:0","series":null,"tags":null,"title":"","uri":"/about/#over-here-stranger"},{"categories":null,"content":" Acredito que o conhecimento se fortalece quando é compartilhado. Por isso, aqui você encontrará conteúdos que vão desde anotações técnicas e práticas de laboratório até reflexões mais amplas sobre processos, arquitetura, tomadas de decisão e caminhos de crescimento.Conecte-se comigo GitHub LinkedIn ","date":"0001-01-01","objectID":"/about/:2:0","series":null,"tags":null,"title":"","uri":"/about/#acredito-que-o-conhecimento-se-fortalece-quando-é-compartilhado-por-isso-aqui-você-encontrará-conteúdos-que-vão-desde-anotações-técnicas-e-práticas-de-laboratório-até-reflexões-mais-amplas-sobre-processos-arquitetura-tomadas-de-decisão-e-caminhos-de-crescimento"}]